# Database

## 事务特性

1. Atomicity
2. Consistent
3. Isolate
4. Durable

## 数据库范式

1. 1NF 列是原子的
2. 2NF 非主属性不能部分依赖主属性
3. 3NF 非主属性间不存在传递依赖

## 脏读，不可重复读，幻读

1. 脏读，A事务还没提交时B事务读取，之后A回滚，B读到脏数据
2. 不可重复读，A事务中会读某个数据多次，B事务在期间修改了数据，A两次读到同一个数据不一致
3. 幻读，A事务修改表中全部数据时，B事务添加了一条数据，A之后发现表中还有未修改数据

## 隔离级别

1. 读未提交
2. 读已提交，解决脏读
3. 可重复读，解决不可重复读
4. 串行化，解决幻读

## 各隔离级别加锁情况

1. read uncommitted 读不加锁，写排他锁
2. read committed 每次读mvcc都生成快照，在快照中索引
3. repeatable read 一次事务只在第一次select生成快照（因为快照只对读操作有效，对写操作无效，所以存在幻读）
4. serialisable 读写均排他锁

## 乐观锁和悲观锁

1. 乐观锁，每次取数据时认为别人都不会修改，所以不上锁，当提交更新时会判断期间数据有无被他人修改
   1. 数据版本，为表增加一个version字段，当读数据时将version字段值一同读出，每次更新数据version+1，当提交时比对version是否过期
   2. 时间戳，添加timestamp字段类型，其他同上
   3. 乐观锁机制避免了长事务中的数据库加锁开销
2. 悲观锁，每次修改数据时都获得锁

## Innodb的两种行级锁

1. s锁，共享，允许事务读取一行数据
2. x锁，排他，允许事务更改一行数据

## innodb三种行锁算法实现隔离级别

1. record locks，锁定索引上的单个记录，若未定义索引，innodb会隐式创建一个聚族索引，并引用改索引锁定记录
2. gap locks，锁定一个范围<>
3. next-key locks，以上的结合，即锁定范围又锁定本身<= =>

## mysql的引擎

1. INNODB
2. MYISAM

## innodb和myisam区别

1. InnoDB 支持事务，MyISAM 不支持事务，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一
2. InnoDB 支持外键，而 MyISAM 不支持
3. InnoDB 是聚集索引，MyISAM 是非聚集索引
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一

## 聚族索引和非聚族索引

1. ![index](./imgdb/index.png)
2. 聚族索引
   1. 数据和索引放在一起
   2. 一个表仅有一个聚族索引，默认为主键，未定义主键时innodb选择一个唯一的非空索引代替，若没有innodb隐式定义一个主键
3. 非聚族索引
   1. 数据和索引分离，得到数据要回表查询

## 二级索引

1. 二级索引即辅助索引
2. 二级索引最终只能拿到主键id，获取内容还需回表
3. 只需要使用到二级索引的查询，不需要进行回表操作的方式称为覆盖索引
   1. 再有索引idx_author_name时，`select id,author,name from book where author = 'author1';`不回表
   2. 主键为a索引为b，c查询where b=10时不会表，查询*也不回表，因为索引包含主键a，同时索引包含b，c
   3. `select * from book where author='author1';` select * 会回表

## 索引的实现

1. B树 / B+树
   1. B树每个节点可以有多个子树，这样一个节点的内容多，树的层数低，有利于磁盘IO（磁盘每次IO会预读，一次可取到一个节点的内容，减少IO次数）
   2. B+树节点只有索引，层数更低，且每次查询都会落到叶子节点，查询稳定
   3. B+树叶子节点有指向右边兄弟的指针，且最后一层数据按索引排列，这样找到起始节点就可以一直向后读到范围结束
2. hash
   1. hash索引查找 O(1)
   2. hash索引只能用来 = IN <= >=，不能用来范围查询

## 最左匹配原则

1. mysql可以建立联合索引（多列的索引）
2. 如果你创建一个联合索引, 那 这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀 就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索 引查询.
3. 其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列 也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询

## mysql模糊查询

1. SELECT 字段 FROM 表 WHERE 某字段 Like 条件
   1. % 匹配任意个字符
   2. _ 匹配单个字符
2. SELECT 字段 FROM 表 WHERE 某字段 REGEXP 正则表达式

## 模糊查询与索引

1. like %keyword 索引失效
   1. 因为任何字符可以匹配 % 无法查找
   2. 可逆序后使用索引，`select * from xxx where mobile_reverse like reverse('%5678');` mobile_reverse存储mobile的倒叙文本
2. like keyword% 索引有效
3. like %keyword% 索引失效，也无法反向索引

## mysql主从复制

1. 做数据热备，当主库挂掉切换到从库
2. 原理
   1. 主数据库的更新事件（update，insert，delete）等事件被写入binlog
   2. 从库连接主库
   3. 主库新建线程，将binlog发送到从库
   4. 从库启动后创建io线程将binlog内容写入到relay log
   5. 从库创建线程从realylog中，从exec_master_log_pos开始执行命令

## 主从延迟

## 复制方式

1. 同步复制，等待所有从库复制后主库返回客户端
2. 异步复制，主库执行完请求后理解返回，不等待从库是否接收并执行完
3. 半同步复制，当有一个从库复制后，主库放回客户端

## mysql命令

1. 按条件计数
   1. `SELECT COUNT(*) FROM `students` GROUP BY `class_id` > 25;`
   2. `SELECT COUNT(*) AS `number`, `class_id` > 25 AS `type` FROM `students` GROUP BY `class_id` > 25;`

## mysql高并发

1. 读多写少
   1. 单个master写，多slave读
2. 写多
   1. 分库
      1. 垂直分库；垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上
      2. 水平分库分表；将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈
   2. 分表
      1. 垂直分表；也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题
      2. 水平分表；针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用
   3. 分库分表后的问题
      1. 事务支持；分库分表后，就成了分布式事务了
      2. 跨库join；分库分表后表之间的关联操作受限，无法join不同分库的表，也无法join分表粒度不同的表
         1. 解决：1.全局表，所有库都拷贝一份 2.系统层组装，分别查出内容后组装

## redis 使用场景

1. 记录帖子点赞数、点击数、评论数
2. 缓存近期热帖
3. 缓存文章详情信息
4. 记录用户会话信息

## redis单线程为什么快

1. 纯内存操作
2. 单线程避免线程上下文切换
3. io复用，epoll lt模式
4. Redis 的瓶颈最有可能是机器内存或者网络带宽，而非单线程，既然单线程不是 Redis 的性能瓶颈，并且单线程又比较容易实现，所以 Redis 就选择使用单线程来实现

## redis功能

1. 数据缓存功能
2. 分布式锁的功能
3. 支持数据持久化
4. 支持事务
5. 支持消息队列

## redis数据类型

1. string
2. hash
3. list
4. set
5. sorted set

## redis对比memcache

1. Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型
2. Redis 的速度比 Memcached 要快
3. Redis 可以持久化
4. Redis 可以设置过期时间
5. Redis 支持主从同步

## redis淘汰策略

1. noeviction：禁止淘汰数据；
2. allkeys-lru：尝试回收最少使用的键，使得新添加的数据有空间存放；
3. volatile-lru：尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放；
4. allkeys-random：回收随机的键使得新添加的数据有空间存放；
5. volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键；
6. volatile-ttl：回收在过期集合的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放

## redis持久化的方式

1. rdb
   1. 缺省情况下，redis将数据快照存放在磁盘的二进制文件中dump.rdb
   2. 可配置持久化策略如多久快照一次，或手动调用save
   3. 实现：redis fork子进程写rdb文件，写完后用新文件代替旧文件
2. AOF
   1. 追加的方式写每条写操做到文件
   2. 重启时优先使用aof重建
3. 对比
   1. RDB需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大
   2. AOF每秒fsync一次指令硬盘，如果硬盘IO慢，会阻塞父进程；风险是会丢失1秒多的数据；在Rewrite过程中，主进程把指令存到mem-buffer中，最后写盘时会阻塞主进程

## SAVE 和 BGSAVE 有什么区别？

1. SAVE 直接调用 rdbSave 函数（用于 Redis 持久化的函数），阻塞 Redis 主进程，直到保存完成为止，在主进程阻塞期间，服务器不能处理客户端的任何请求；
2. BGSAVE 则会创建一个子进程，子进程负责调用 rdbSave 函数，并在保存完成之后向主进程发送完成信号，Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求

## 跳表

1. ![skiplist](./img/../imgdb/skiplist.png)
2. 跳跃表是一种基于链表的扩展，跳跃表还是一个链表，是一个有序的链表，在遍历的时候基于比较，但普通链表只能遍历，跳跃表加入了一个层的概念，层级越高元素越少，每次先从高层查找，直到找到合适的位置，从图中可以看到高层的节点远远少于底层的节点数，从而实现了跳跃式查找

## redis缓存穿透，缓存击穿和缓存雪崩

1. 缓存穿透
   1. 访问不存在的key，每次请求落在数据库，高并发时挂掉
   2. 解决，直把null设为缓存;不管查询数据库是否有数据，都缓存起来，只不过把没有数据的缓存结果的过期时间设置为比较短的一个值，比如 3 分钟
2. 缓存击穿
   1. 大量数据访问同一个key（如秒杀），缓存过期的瞬间大量请求落在数据库
   2. 解决，不过期
3. 缓存雪崩
   1. 大量key同时过期
   2. 解决：随机key的过期时间；热点数据考虑不失效

## Redis 有哪些集群策略

1. 主从策略：1 台机器作为写操作，另外 2 台作为读操作，类似于 MySQL 的主从方式；
2. 哨兵策略：增加 1 台机器作为哨兵，监控 3 台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务；
3. 集群策略：Redis 3.0 之后增加了集群的概念，可实现多主多从的结构，实现正真的高可用

## redis高并发高可用

1. 高并发
   1. 单机，主从架构，单master写数据，多slave读数据，读写分离
   2. 集群，
2. 高可用
   1. 哨兵，监视master运行状态，当多数认为master挂了，在slave中投票选出一个master

## 如何保证 Redis 的数据一致性

1. 合理设置缓存的过期时间；
2. 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性

## 什么是缓存预热？有几种实现方式

1. 缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。
2. 缓存预热的实现方式，可分为以下两种：
   1. 数据量不大的时候，工程启动的时候进行加载缓存动作
   2. 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新

## Redis 是如何实现同步的？

1. Redis 可以实现主从同步和从从同步。当第一次同步时，主节点做一次 BGSAVE，并同时将后续修改操作记录到内存中，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存，加载完成后再通知主节点将期间修改的操作记录，同步到复制节点进行重放，这样就完成了同步过程

## redis分布式锁

1. setnx命令，意思就是 set if not exist，如果lockKey不存在，把key存入Redis，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。
2. expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁
3. 加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，相当于这个锁没有过期时间，有产生死锁的可能
4. 将加锁和设置过期时间合二为一，一行代码搞定，原子操作

```java
Long result = jedis.setnx(lockKey, requestId);
if (result == 1) {
   // 第二步：设置过期时间
   jedis.expire(lockKey, expireTime);
}

if (1 == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)) {
      return true;//加锁成功        
}        
return false;//加锁失败
```

## cap原理

1. CAP原理认为，一个提供数据服务的存储系统无法同时完美的满足
   1. 一致性（Consistency，一致性指的是所有节点都能在同一时间返回同一份最新的数据副本
   2. 数据可用性（Availability），可用性指的是每次请求都能够返回非错误的响应
   3. 分区耐受性（Partition Tolerance），分区容错性指的是服务器间的通信即使在一定时间内无法保持畅通也不会影响系统继续运行
2. Consistency 和 Availability 的矛盾，一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

## raft协议

1. raft解决以下三个问题
   1. leader选举：当已有的leader故障时必须选出一个新的leader
   2. 日志复制：leader接受来自客户端的命令，记录为日志，并复制给集群中的其他服务器，并强制其他节点的日志与leader保持一致
   3. 安全safety措施：通过一些措施确保系统的安全性，如确保所有状态机按照相同顺序执行相同命令的措施
2. Raft协议的每个副本都会处于三种状态之一
   1. Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本
   2. Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件
   3. Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束
   4. 开始时大家都是folloer然后拉票，票多的人成为leader，若一次投票没有投出，因为每个follower的等待超时不同，会有先的follower开始第二次选举