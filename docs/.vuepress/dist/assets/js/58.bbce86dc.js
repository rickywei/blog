(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{455:function(e,t,a){"use strict";a.r(t);var i=a(25),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"unix-thread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unix-thread"}},[e._v("#")]),e._v(" Unix Thread")]),e._v(" "),a("h2",{attrs:{id:"thread-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-control"}},[e._v("#")]),e._v(" Thread Control")]),e._v(" "),a("ol",[a("li",[e._v("Each thread indicated by tid, tid has is context in a process")]),e._v(" "),a("li",[e._v("New thread start from its function's address, no promise on new thread or call thread run firstly")]),e._v(" "),a("li",[e._v("Can use join() to let call thread wait(blocked) new thread finish, use detach() to let new thread be controled by OS")]),e._v(" "),a("li",[e._v("New thread must be join() or detach() to promise rousource is released")]),e._v(" "),a("li",[e._v("thread end\n"),a("ol",[a("li",[e._v("Return from function, return value is thread's exit code")]),e._v(" "),a("li",[e._v("Cancled by other thread in the same process")]),e._v(" "),a("li",[e._v("Thread's stack can be resued when it finish")]),e._v(" "),a("li",[e._v("Thread can set a function which will be called when exit.")])])]),e._v(" "),a("li",[e._v("A process has limitation on thread number")]),e._v(" "),a("li",[e._v("Reentrancy\n"),a("ol",[a("li",[e._v("thread safe means a function can be called by many thread and run correctly")]),e._v(" "),a("li",[e._v("POSIX provide some thread safe version function, named by funcname_r")]),e._v(" "),a("li",[e._v("Many function is not thread safe since they put return value in static memory")])])]),e._v(" "),a("li",[e._v("thread-private data")]),e._v(" "),a("li",[e._v("thread call fork()\n"),a("ol",[a("li",[e._v("Child get copy of both space and mutex, condition")]),e._v(" "),a("li",[e._v("Child only has one thread, its the copy of thread of parent who calls fork()")])])])]),e._v(" "),a("h2",{attrs:{id:"thread-synchronization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-synchronization"}},[e._v("#")]),e._v(" Thread Synchronization")]),e._v(" "),a("ol",[a("li",[e._v("Non-atom operation can be interrupted at any time")]),e._v(" "),a("li",[e._v("Mutex(lock)\n"),a("ol",[a("li",[e._v("Normal lock\n"),a("ol",[a("li",[e._v("Lock need to be initialized")])])]),e._v(" "),a("li",[e._v("lock with timer")]),e._v(" "),a("li",[e._v("Read-write lock\n"),a("ol",[a("li",[e._v("3 status, read lock, write lock, no lock")]),e._v(" "),a("li",[e._v("Only one thread can occupy write lock, but read lock can be occupied by many thread")]),e._v(" "),a("li",[e._v("The write lock will block any r/w lock")])])]),e._v(" "),a("li",[e._v("Spine lock\n"),a("ol",[a("li",[e._v("block thread by busy-wait rather than sleep")])])]),e._v(" "),a("li",[e._v("Condition variable\n"),a("ol",[a("li",[e._v("Condition variable need to be initialized")])])]),e._v(" "),a("li",[e._v("barrier")])])])]),e._v(" "),a("h2",{attrs:{id:"dead-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dead-lock"}},[e._v("#")]),e._v(" Dead lock")]),e._v(" "),a("ol",[a("li",[e._v("when happens\n"),a("ol",[a("li",[e._v("Mutual Exclusion")]),e._v(" "),a("li",[e._v("Hold and Wait")]),e._v(" "),a("li",[e._v("No Preemption")]),e._v(" "),a("li",[e._v("Circular Wait")])])])])])}),[],!1,null,null,null);t.default=n.exports}}]);